<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0049)https://javaranch.com/journal/200607/Plugins.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" type="text/css" href="./Adding Plugins to a Java Application_files/stylesheet.css" title="Style">
  <title>Adding Plugins to a Java Application</title>
</head>
<body>
<center><font color="#804040" size="+2"><b>Adding Plugins to a Java Application</b></font><br>
<i>by <a href="http://www.javaranch.com/contact.jsp#UlfDittmer" target="_blank">Ulf Dittmer</a></i>
</center>
<div>
   <p>No matter how many functions an application has, there are times when a user wants to do something that the original developers have not foreseen, and which is not included in the application. Even worse, it might be something really specialized that only she needs, and which will never be added by the software vendor. One solution might be to export the data, work on it with a different application which has the desired functionality, and then re-import it. Another option would be to extend the application by using its API, if it provides one. One way of doing so is through plugins: chunks of external code that are accessed through the application, and use its API to perform a function that the application itself can't.</p>
   
   <p>One application whose plugin API is very successful is Adobe Photoshop, which even spawned a market for commercially available plugins. While Photoshop plugins are written in C, the mechanism is really language-independent, although it is constrained by the language the host application is written in. This article shows how a plugin API can be added to Java applications.</p>
   
   <p>(Examples of Java plugins in a broader sense would also be the Applet API in web browsers, and the Servlet API in web servers. These are atypical, though, and what is described here is more like what Photoshop does.)</p>
   
   <p>Generally speaking, there are four steps involved in the process. </p>
   <ol>
   <li>define an API, i.e. a Java interface, for the plugin to implement
   </li><li>determine how the host application gets to know which plugins are available, and where to find them
   </li><li>write a ClassLoader that loads the plugin classes
   </li><li>write a SecurityManager that governs what plugins are allowed to do
   </li></ol>
   <p>Figure 1 shows the various pieces of code that help implement all of this.</p>
   
   <p><img alt="Figure 1: Components of the plugin mechanism" src="./Adding Plugins to a Java Application_files/components.jpg"></p>
   <p>Figure 1: Components of the plugin mechanism; <b>PluginDemo</b> is an example application that shows the various pieces in action</p>
   <h2>Step 1: Defining the API</h2>
   
   <p>In order for the host application to treat all plugins the same way, we define an interface which the plugins need to implement. The methods of the interface can be thought of as ”lifecycle“ methods - operations the host application calls to initialize a plugin, set parameters, execute it, get results and shut it down. In the example, we require plugins to implement the <span style="font-family:&#39;Courier&#39;">PluginFunction </span>interface. It defines four methods:</p>
   
   <ul>
   <li><span style="font-family:&#39;Courier&#39;">public String getPluginName();</span>
   <p>which returns the name of the plugin, so that it can be displayed to the user in some way</p>
   </li><li><span style="font-family:&#39;Courier&#39;">public void setParameter (int param);</span>
   <p>which lets the hosting application set a parameter for the plugin to work with</p>
   </li><li><span style="font-family:&#39;Courier&#39;">public int getResult();</span>
   <p>through which the application can retrieve the result of the plugins work, i.e. the actual workhorse call</p>
   </li><li><span style="font-family:&#39;Courier&#39;">public boolean hasError();</span>
   <p>which signals that the previous call to the plugin was not successful </p>
   </li></ul>
   <p>Looking at these calls, it's clear that the plugins are rather limited - there is just a single functional call, which takes an integer parameter and returns an integer result. Real plugins would likely have methods for initialization and cleanup, and probably more than one functional method.</p>
   
   <p>A more powerful approach might involve several different interfaces, with differing characteristics and different lifecycle methods. E.g., there could be plugins with and without a GUI, or plugins that receive and return more complex types, or that require a more complicated flow of control. But for the introductory purposes of this article, we limit ourselves to the interface shown above.</p>
   <h2>Step 2: Determine plugin acquisition</h2>
   
   <p>We need to define how a an application acquires or gets to know about plugins. In this example we confine ourselves to loading plugins from a particular directory on the local hard disk, which is a common way for desktop applications. The directory will be called ”<span style="font-family:&#39;Courier&#39;">plugins</span>“, and is located directly inside the main application directory.</p>
   <p>One important question to consider is at which time the application scans the directory to discover plugins. The easiest way is to do it just once at startup, at which time the plugins haven't been loaded and run yet. With a bit more work one could allow plugins to be added later, i.e., scan the directory again, and add any plugins that weren't there during the previous scan.</p>
   <p>A useful feature is to be able to update plugins without the need to stop and restart the host application. For server applications in particular this would be unfeasible, especially in a production setting. The problem with updating plugins -which are essentially Java classes- is that once a class is loaded, it can't be unloaded. In some circumstances it may be possible by discarding the ClassLoader that loaded the class, but if objects of the class are long-lived (perhaps because the application keeps references to them), then even that would not work.</p>
   <h2>Interlude: ClassLoader and SecurityManager</h2>
   
   <p>OK then. There's been talk of class loaders, but what do those have to do with plugins? To fully understand the reasons, we need to look at security managers as well. Although those two concepts have been part of the Java API since version 1.0 (that was back in 1995, folks), and are crucial pieces of the Java infrastructure, it's perfectly possible to develop with Java for years, and never have to deal with either of them directly.</p>
   <p>Class loading is comparable in some way to linking: it deals with how the JVM finds and accesses classes. The system classes that make up the Java API are available automatically to all Java applications, but other classes must be be added in specific ways so that the JVM knows how to find them. E.g., web applications look for additional classes in the <span style="font-family:&#39;Courier&#39;">WEB-INF/lib </span>and <span style="font-family:&#39;Courier&#39;">WEB-INF/classes </span>directories, while applets load classes over HTTP from the host they were served from, and desktop applications look at an environment variable called <span style="font-family:&#39;Courier&#39;">CLASSPATH </span>and a command-line switch named <span style="font-family:&#39;Courier&#39;">-classpath</span>.</p>
   <p>So one reason why we need our own class loader is that it needs to look into the <span style="font-family:&#39;Courier&#39;">plugins </span>directory for additional classes. We could add that directory to the classpath, and thus have the application class loader load those classes just like all other ones, but that would run counter to the second reason: we don't trust plugin classes. Yes, that's right: after all the effort to produce a functional, well-tested, bug-free and useful plugin, the application does not trust it to do the right thing. No way. Remember that the reason we have a plugin mechanism in the first place, is to add functionality to the application by someone other than the application developer. It could be you (who you trust), it could be someone in your company (who you probably trust), it could be your buddy's nephew (who you possibly trust, but maybe not), or someone on the other side of the planet, who you don't trust right away, but whose plugin you still want to use.</p>
   <p>The solution is to run the plugin code in a <span style="font-style:italic">sandbox, </span>where it has limited rights, and can do little or no harm. For example, a plugin should most definitely not be able to read the tax return files from your local hard disk and upload them someplace else. The sandbox can be established by using a security manager. Most Java desktop applications are run without one, on the premise that you trust any application that you install and run on your local machine. But plugins violate this premise, so we need to distinguish between trusted code (the Java class libraries) and untrusted code (the plugin), and prevent the untrusted code from doing bad things. Using a class loader helps with the former -it can determine which class loader loaded a particular class-, while a security manager accomplishes the latter - it can define in a very fine-grained way which operations a particular class is or is not allowed to do. For example, access to the local filesystem is right out, as are any network operations, or the ability to call System.exit and thus cause the application to quit.</p>
   <p>And now, back to the four-step program.</p>
   <h2>Step 3: Creating a ClassLoader</h2>
   
   <p>From the above it may seem that class loaders are arcane and tricky to develop. Fortunately, that's not the case. When extending <span style="font-family:&#39;Courier&#39;">java.lang.ClassLoader</span>, there's only a single method to implement. It gets passed a string with the name of the class to load, and hands back a <span style="font-family:&#39;Courier&#39;">Class </span>object of that class. From that object, the application can then instantiate the runtime objects of the plugin class.</p>
   <p>Let's look at the source of <span style="font-family:&#39;Courier&#39;">PluginClassLoader</span>. In its constructor, we tell it which directory the plugins are in. We could have hardcoded that, since there is no way to change it in the application, but this bit of flexibility makes the class more easily reusable. All the interesting action is in the <span style="font-family:&#39;Courier&#39;">loadClass </span>method. Three cases need to be considered: 1) the class is loaded already, in which case it can be found in the cache that is kept of all loaded classes, 2) the class to be loaded is a system class, in which case the loading is delegated to the system ClassLoader, and 3) if neither of the above, then the plugin directory is examined if it contains a class file with the required name. If it does, then the bytes that physically make up the class are loaded, and handed off to the <span style="font-family:&#39;Courier&#39;">defineClass </span>method (which <span style="font-family:&#39;Courier&#39;">java.lang.ClassLoader </span>implements, so we don't need to worry about it). The result is the desired <span style="font-family:&#39;Courier&#39;">Class </span>object, which can then be returned from the method. We're done!</p>
   <p>Note that this class loader only deals with class files, not jar or zip files. But support for those can be added simply by more elaborate file I/O, and has little to do with class loading per se, so we won't implement that here (that would be a good exercise for the reader, though).</p>
   <p><img alt="Figure 2: Loading plugins with a class loader" src="./Adding Plugins to a Java Application_files/getPlugins.jpg"></p>
   <p>Figure 2: Loading plugins with a class loader</p>

   <h2>Step 4: Creating a SecurityManager</h2>
   
   <p>Just like with the class loader, writing the security manager is made easier by the fact that we can extend <span style="font-family:&#39;Courier&#39;">java.lang.SecurityManager</span>, and only need to override the methods that specify what permissions to grant and which to deny. If you look at the source of <span style="font-family:&#39;Courier&#39;">PluginSecurityManager</span>, you'll see plenty of methods named <span style="font-family:&#39;Courier&#39;">checkXYZ</span>. Each one of those checks whether access to some specific system feature should be allowed or denied. There are a few methods dealing with file I/O, a few about network activity, and a number of other ones like printer access, clipboard access, execution of external code, access to system properties and quitting the application. Every single one of these in turn calls the <span style="font-family:&#39;Courier&#39;">trusted </span>method, which simply checks whether the executing code runs inside a class loader (a different one than the application class loader, that is). If it is -meaning the code currently running is plugin code- an exception is thrown, which signals to the JVM that the requested action should be denied.</p>
   <p>So, you ask, if everything is denied, then what <span style="font-style:italic">can </span>the plugins do? Still plenty, actually. It's just that everything they need to have in order to run must already be part of the class, or be passed in through the <span style="font-family:&#39;Courier&#39;">setParameter </span>method. Going back to the example of Photoshop plugins, even though file import or export of images wouldn't be possible, any kind of filtering of an image would be perfectly possible.</p>
   <p>It is also possible to differentiate permissions based on what kind of class is executing. If a plugin implements some kind of I/O interface, access to disks could selectively be allowed. </p>
   <p><img alt="Figure 3: Initialization of the security manager" src="./Adding Plugins to a Java Application_files/initialization.jpg"></p>
   <p>Figure 3: Initialization of the security manager</p>
   <p><img alt="Figure 4: Running plugins with a security manager" src="./Adding Plugins to a Java Application_files/runPlugins.jpg"></p>
   <p>Figure 4: Running plugins with a security manager</p>

   <h2>Examples</h2>
   
   <p>To illustrate the technique, we look at a simple example application, <span style="font-family:&#39;Courier&#39;">PluginDemo</span>. It chiefly consists of two methods: <span style="font-family:&#39;Courier&#39;">getPlugins</span>, which searches through the <span style="font-family:&#39;Courier&#39;">plugins </span>directory for classes that implement the <span style="font-family:&#39;Courier&#39;">PluginFunction </span>interface and loads and instantiates the ones it finds, and <span style="font-family:&#39;Courier&#39;">runPlugins</span>, which in turn tries to run each plugin by calling its <span style="font-family:&#39;Courier&#39;">getResult </span>method (after first setting its only parameter by calling <span style="font-family:&#39;Courier&#39;">setParameter</span>).</p>
   
   <p>1) Unpack the <a href="https://javaranch.com/journal/200607/plugins.zip">zip file containing the sample code</a>, and run the <span style="font-family:&#39;Courier&#39;">PluginDemo </span>application by typing ”<span style="font-family:&#39;Courier&#39;">java -classpath . PluginDemo</span>“ on the command line. The output is:</p>
   <p><span style="font-family:&#39;Courier&#39;">FortyTwo ( 1 ) = 42</span></p>
   <p><span style="font-family:&#39;Courier&#39;">PlusOne ( 2 ) = 3</span></p>
   <p><span style="font-family:&#39;Courier&#39;">Square ( 3 ) = 9</span></p>
   <p>That means that 3 plugins were found, named ”FortyTwo“, ”PlusOne“ and ”Square“, respectively. To each it passed the parameter shown in parentheses via the <span style="font-family:&#39;Courier&#39;">setParameter </span>method, and got from it the result shown to the right of the ”=“ sign, via the <span style="font-family:&#39;Courier&#39;">getResults </span>method. The plugins perform simple tasks: The first one always returns 42 regardless of the parameter, the second adds 1 to the parameter, and the third squares it.</p>
   
   <p>If you look at the source of the plugins, you'll notice that they are <b>not</b> in a package named ”<span style="font-family:&#39;Courier&#39;">plugins</span>“. The fact that they can be loaded and run is thus not due to the classpath being set to the current directory, but to the class loader that looks for classes in a directory named <span style="font-family:&#39;Courier&#39;">”plugins“</span>.</p>
   
   <p>2) Now move the <span style="font-family:&#39;Courier&#39;">Fibonacci.class </span>file from the <span style="font-family:&#39;Courier&#39;">other </span>directory to the <span style="font-family:&#39;Courier&#39;">plugins </span>directory and re-run the application. You'll see that there is now another line of output, showing the result of the call to the <span style="font-family:&#39;Courier&#39;">Fibonacci </span>plugin. Since this one is a tiny bit more involved, it can signal an error (if the parameter is smaller than zero, since the Fibonacci function is defined for positive numbers only). The <span style="font-family:&#39;Courier&#39;">hasError </span>method implements a simple way for a plugin to signal an error condition to the host application. Keep in mind that this is very basic, merely meant to illustrate the technique.</p>
   
   <p>3) Now move the <span style="font-family:&#39;Courier&#39;">TryToExit.class </span>file to the <span style="font-family:&#39;Courier&#39;">plugins </span>directory as well. The other plugins run as they did before, but the new one causes a security exception, which <span style="font-family:&#39;Courier&#39;">PluginDemo </span>catches. It responds to that by printing a message telling us that something forbidden was prevented. What exactly was that? The plugin is basically a copy of <span style="font-family:&#39;Courier&#39;">FortyTwo</span>, but it has an additional line calling <span style="font-family:&#39;Courier&#39;">System.exit</span>, which is not allowed by the security managers <span style="font-family:&#39;Courier&#39;">checkExit </span>method.</p>
   
   <p>As an experiment, make a copy of <span style="font-family:&#39;Courier&#39;">TryToExit.class</span>, and place it in the same directory as the <span style="font-family:&#39;Courier&#39;">PluginDemo </span>class. If you rerun it, something strange happens - no result is printed for the plugin. That's because this time, the call to <span style="font-family:&#39;Courier&#39;">System.exit </span>succeeded, and the application just quit before execution returned to the host application. Why would it do that? Because <span style="font-family:&#39;Courier&#39;">TryToExit </span>is now part of the regular classpath, and loaded by the application class loader, not the plugin class loader. That means it is run without a security manager, and thus no checks and balances apply to its execution.</p>
   <p>This demonstrates that particular care must be taken in where to put classes when multiple class loaders are involved, or strange and undesirable things can happen.</p>
   
   <p>4) Now move the last plugin, <span style="font-family:&#39;Courier&#39;">ReadFile.class</span>, to the plugins directory as well. It reads two numbers from a file called <span style="font-family:&#39;Courier&#39;">input.txt</span>, and returns their sum as the result (yes, you're right, it's not a very useful function, but it illustrates the principle). The execution of the plugin is prevented -this time because file I/O is not allowed-, but now we want it to succeed, so we'll have to modify the security manager.</p>
   <p>Take a look at the source of <span style="font-family:&#39;Courier&#39;">PluginSecurityManager</span>, and search for the <span style="font-family:&#39;Courier&#39;">checkRead </span>method. You'll find 3 of them, but we're only interested in the one that takes a <span style="font-family:&#39;Courier&#39;">String </span>parameter. As it is, it ignores which file should be read, and simply calls <span style="font-family:&#39;Courier&#39;">trusted() </span>to check for the presence of a class loader. If we remove the comment slashes of the two lines before that, we have enabled it to actually look at the file that should be read, and if that is inside the <span style="font-family:&#39;Courier&#39;">plugins </span>directory, the method simply returns. Thus no security exception is thrown, which signals to the application that the file is allowed to be read. Now compile it with those lines activated, and rerun the application.</p>
   <p>But no dice - we're still not allowed to access the file. Time to study the javadocs of the file I/O methods we use. The <span style="font-family:&#39;Courier&#39;">getParentFile </span>method doesn't do anything illegal, but <span style="font-family:&#39;Courier&#39;">getAbsolutePath </span>is declared to throw a <span style="font-family:&#39;Courier&#39;">SecurityException </span>if a required system property can't be accessed. This is governed by the <span style="font-family:&#39;Courier&#39;">checkPropertyAccess </span>method of the security manager. By printing out the property keys that are passed to it, we can determine that it's the <span style="font-family:&#39;Courier&#39;">user.dir </span>property which is needed here. So we allow it to access that particular property by specifically checking for it, and then skipping the call to <span style="font-family:&#39;Courier&#39;">trusted</span>. If you recompile the class after commenting in the additional line in that method, and then rerun the application, no exceptions will occur, and the sum of the two numbers in the file will be printed as result of the plugin call.</p>
   <p>This goes to show that securing an application is a very fine-grained process, where great care must be taken to determine what to allow whom to do.</p>
   <h2>Wrapping up</h2>
   
   <p>Creating a plugin API is a powerful way to extend an applications usefulness. It is rarely possible to foresee precisely how an application might get used, and letting a user extend what it can do is a good way of dealing with that. In addition to calling more or less passive methods -like the above example does-, we could also let plugins play more active roles. An event interface could be defined that allows a plugin to be called whenever certain system events occur. Furthermore, the parameters passed to the plugin might include application-internal data structures that would allow the plugin to manipulate the host application in very fundamental ways.</p>
   
   <p>If you're interested in studying a more complex example of a successful plugin API, I recommend having a look at ImageJ (http://rsb.info.nih.gov/ij/). It's a public domain image processing application and library, so the source is available. Its plugin API allows a user to add custom image processing capabilities, advanced automation techniques, and support for a number of image formats which the application itself does not handle. The plugin support revolves around the <span style="font-family:&#39;Courier&#39;">ij.plugin.PlugIn </span>interface (for plugins that create windows) and <span style="font-family:&#39;Courier&#39;">ij.plugin.filter.PlugInFilter </span>(for plugins that operate on existing images). ImageJ employs a particular directory (called <span style="font-family:&#39;Courier&#39;">plugins</span>) which it searches for classes implementing one of these two interfaces. Those it displays in a menu called <span style="font-family:&#39;Courier&#39;">Plugins</span>, thus allowing the user to select them to run. Plugins can also be loaded from jar files. Since most ImageJ plugins are distributed with source and are thus open to inspection, the plugin handler does not concern itself with security, and doesn't use class loaders or security managers. A wide variety of plugins are available at http://rsb.info.nih.gov/ij/plugins.html.</p>
   
   <p>Before we part, it's time to confess something: creating security managers in the way shown here is considered obsolete, which is why you'll get plenty of obsolescence warnings when compiling <span style="font-family:&#39;Courier&#39;">PluginSecurityManager</span>. Java 2 introduced a newer method based on declarative security and the <span style="font-family:&#39;Courier&#39;">Permission </span>class, which is now the preferred way of securing Java code. The problem with the old-style approach is that each time new methods are added to the class library which do something potentially dangerous, new methods need to be added to all security managers: it's programmatic security, not declarative security like the permissions scheme allows. But the approach used here is still fully functional, and adequate for the purposes of a plugin handling mechanism, where the API changes rarely, if ever.</p>
  </div>
 


</body></html>